## 정렬

- 데이터를 특정한 기준에 따라 순서대로 나열

  

#### 선택정렬

- 처리되지 않은 데이터 중 // 가장 작은 데이터를 선택해 맨 앞에 있는 데이터와 바꾸는 것을 반복
- 탐색 범위는 점점 작아지고, 탐색범위 만큼 가장 작은 데이터를 찾아야 하기 때문에 선형 탐색 - 이중 반복문

- 시간복잡도 O(N*N)

#### 삽입정렬

- 처리되지 않은 데이터를 하나씩 골라 적절한 위치에 삽입
- 선택 정렬 보다 효율적
- 시간복잡도 O(N*N), but 데이터가 거의 정렬된 상태라면  O(N)

#### 퀵정렬

- 기존 데이터를 설정하고// 그 기준보다 큰 데이터와 작은 데이터의 위치를 바꾸는 방법

- 가장 많이 사용

- 병합 정렬과 더불어 근간이 되는 정렬 알고리즘

- 첫 번째 데이터를 기준 데이터(PIVOT)로 설정

- 시간복잡도 이상적인 경우, N* O(logN) = 너비 * 높이 => 분할이 절반씩 일어난다면, 최악의 경우  O(N*N) => 0 1 2 3 4 5 6 7 8 9  인경우 피벗이 N개를 기준으로 정렬하기 때문 

  

#### 계수 정렬

- 매우 빠르게 동작

- 데이터의 크기 범위가 제한되어 정수형태로 표현할 수 있을때 사용

- 데이터 개수 N, 데이터 중 최댓값 K일 대 , 최악의경우에도 수행시간(n+k)

- 동일한 값을 가지는 데이터가 여러개 존재할때 사용

  

| 정렬 알고리즘 | 평균시간 복잡도 | 공간 복잡도 | 특징                                    |
| :------------ | --------------- | ----------- | --------------------------------------- |
| 선택 정렬     | O(N*N)          | O(N)        | 간단                                    |
| 삽입 정렬     | O(N*N)          | O(N)        | 정렬되어 있을 때 효율                   |
| 퀵 정렬       | O(N*logN)       | O(N)        | 충분히 빠름                             |
| 계수 정렬     | O(N+k)          | O(N+k)      | 데이터 크기 한정되어 있을 때 효율, 빠름 |

- 공간복잡도 : 메모리 사용량

#### 그림으로 이해하기
![KakaoTalk_20210125_140741708](https://user-images.githubusercontent.com/38436013/105663948-c68d4b80-5f16-11eb-8a71-130f13736ece.jpg)
![KakaoTalk_20210125_140741708_01](https://user-images.githubusercontent.com/38436013/105663959-cf7e1d00-5f16-11eb-9361-51a6891e91bf.jpg)

